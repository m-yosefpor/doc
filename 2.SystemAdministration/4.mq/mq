DECOUPLING: A decoupled architecture is where the different components/layers that make up the system interact with each other using well-defined interfaces rather than depending tightly on each other. With such an architecture, the components/layers can be developed independently without having to wait for their dependencies to complete. This leads to pipelined development, resulting in more streamlined and faster development. This also improves testability of the components.By using a queue between different component you can decouple the dependencies. The format of the message in the queue becomes your data contract and anything that knows how to read that message format can be used to process the transaction. This could be useful for parts of your code that are even written in different programming languages.
SCALABILITY : Because message queues decouple your system/component, it’s easy to scale up every individual component without worrying about any code change or configuration change.
PERSISTENCE : Every system/application has some issues, it crashes, bugs, error etc are part of this. If your data is not persisted, it is gone for forever. MQs provide this data persistency. Queues mitigate this by persisting data until it has been fully processed. The put-get-delete paradigm, which many message queues use, requires a process to explicitly indicate that it has finished processing a message before the message is removed from the queue, ensuring your data is kept safe until you’re done with it.
TRAFFIC SPIKES : You don’t always know exactly how much traffic your application is going to have. By queuing the data we can be assured the data will be persisted and then be processed eventually, even if that means it takes a little longer than usual due to a high traffic spike.
MONITORING : Message queuing systems enable you to monitor how many items are in a queue, the rate of processing messages, and other stats. This can be very helpful from an application monitoring standpoint to keep an eye on how data is flowing through your system and if it is getting backed up.
ASYNCHRONOUS COMMUNICATION : A lot of times, you don’t want to or need to process a message immediately. Message queues enable asynchronous processing, which allows you to put a message on the queue without processing it immediately. Queue up as many messages as you like, then process them at your leisure.
BATCH PROCESS : Message queues are very useful when we want to do a Batching. For Eample — It is much more efficient to insert 1000 records into a database at a time instead of 1 at a time, 1000 times. We insert a lot of data into elasticsearch and SQL Server. Batching helps us optimize their performance by tuning the size of the transactions.
ORDERING : Message queues are inherently ordered, and capable of providing guarantees that data will be processed in a specific order (FIFO).
DELIVERY : No matter how many processes are pulling data from the queue, each message will only be processed a single time.
DATA FLOW : In a distributed system, getting an overall sense of how long user actions take to complete and why is a huge problem. Message queues, through the rate with which they are processed, help to easily identify under-performing processes or areas where the data flow is not optimal.
